{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"api/","title":"API Reference","text":"<p>Here you can find the API reference for Qadence 2 Platforms.</p> <p>It is divided according to the modules present in the package, to name:</p> <ul> <li><code>abstracts</code>: Defines the <code>AbstractInterface</code> class.</li> <li><code>compiler</code>: Defines the <code>compile_to_backend</code> function to access the backend <code>Interface</code> instance.</li> <li><code>backends</code>: Defines all the built-in backends implementations.</li> </ul>"},{"location":"api/abstracts/","title":"Qadence 2 platforms abstract interfaces","text":""},{"location":"api/abstracts/#qadence2_platforms.abstracts.AbstractInterface","title":"<code>AbstractInterface</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[ArrayType, SequenceType, ParameterType, RunResultType, SampleResultType, ExpectationResultType]</code></p> <p>An abstract base class that defines interface essential methods.</p> <p>It should be inherited by any class that needs to implement a backend, for instance <code>pyqtorch</code> and <code>fresnel1</code> (<code>pulser</code> using <code>qutip</code> emulator). It is not only used by the package itself, but users who want to implement or test new backends should also make use of it.</p>"},{"location":"api/abstracts/#qadence2_platforms.abstracts.AbstractInterface.info","title":"<code>info: dict[str, Any]</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Gives any relevant information about the interface data, such as <code>device</code>, <code>register</code>, etc.</p> <p>:return: dictionary with the relevant information.</p>"},{"location":"api/abstracts/#qadence2_platforms.abstracts.AbstractInterface.sequence","title":"<code>sequence: SequenceType</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Outputs the backends-native sequence.</p> <p>:return: The defined backends-native sequence.</p>"},{"location":"api/abstracts/#qadence2_platforms.abstracts.AbstractInterface.draw","title":"<code>draw(values)</code>  <code>abstractmethod</code>","text":"<p>May draw the current sequence with the given values.</p> PARAMETER DESCRIPTION <code>values</code> <p>the values to be drawn</p> <p> TYPE: <code>dict[str, Any]</code> </p> Source code in <code>qadence2_platforms/abstracts.py</code> <pre><code>@abstractmethod\ndef draw(self, values: dict[str, Any]) -&gt; None:\n    \"\"\"\n    May draw the current sequence with the given values.\n\n    Args:\n        values (dict[str, Any]): the values to be drawn\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/abstracts/#qadence2_platforms.abstracts.AbstractInterface.expectation","title":"<code>expectation(values=None, observable=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Computes the expectation value for observable(s) given the parameters (values), and extra arguments.</p> <p>:param values: dictionary of user-input parameters :param observable: list of observables :param kwargs: any extra argument that are backends specific can be included in the     child method :return: any result type according to what is expected by the backends <code>expectation</code> method</p> Source code in <code>qadence2_platforms/abstracts.py</code> <pre><code>@abstractmethod\ndef expectation(\n    self,\n    values: dict[str, ArrayType] | None = None,\n    observable: Any | None = None,\n    **kwargs: Any,\n) -&gt; ExpectationResultType:\n    \"\"\"\n    Computes the expectation value for observable(s) given the parameters (values),\n    and extra arguments.\n\n    :param values: dictionary of user-input parameters\n    :param observable: list of observables\n    :param kwargs: any extra argument that are backends specific can be included in the\n        child method\n    :return: any result type according to what is expected by the backends `expectation` method\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/abstracts/#qadence2_platforms.abstracts.AbstractInterface.parameters","title":"<code>parameters()</code>  <code>abstractmethod</code>","text":"<p>Get the parameters from the backend as an iterable.</p> RETURNS DESCRIPTION <code>Iterable[Any]</code> <p>Parameters as an iterable.</p> Source code in <code>qadence2_platforms/abstracts.py</code> <pre><code>@abstractmethod\ndef parameters(self) -&gt; Iterable[Any]:\n    \"\"\"\n    Get the parameters from the backend as an iterable.\n\n    Returns:\n        Parameters as an iterable.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/abstracts/#qadence2_platforms.abstracts.AbstractInterface.run","title":"<code>run(values=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Gets the results from the expression computation given the parameters (values), and extra arguments.</p> <p>:param values: dictionary of user-input parameters :param kwargs: any extra argument that are backends specific can be included in the     child method. :return: any result type according to what is expected by the backends <code>run</code> method</p> Source code in <code>qadence2_platforms/abstracts.py</code> <pre><code>@abstractmethod\ndef run(\n    self,\n    values: dict[str, ArrayType] | None = None,\n    **kwargs: Any,\n) -&gt; RunResultType:\n    \"\"\"\n    Gets the results from the expression computation given the parameters (values),\n    and extra arguments.\n\n    :param values: dictionary of user-input parameters\n    :param kwargs: any extra argument that are backends specific can be included in the\n        child method.\n    :return: any result type according to what is expected by the backends `run` method\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/abstracts/#qadence2_platforms.abstracts.AbstractInterface.sample","title":"<code>sample(values=None, shots=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Samples the computed result given the expression, the parameters (values), number of shots, and extra arguments.</p> <p>:param values: dictionary of user-input parameters :param shots: number of shots :param kwargs: any extra argument that are backends specific can be included in the     child method :return: any result type according to what is expected by the backends <code>sample</code> method</p> Source code in <code>qadence2_platforms/abstracts.py</code> <pre><code>@abstractmethod\ndef sample(\n    self,\n    values: dict[str, ArrayType] | None = None,\n    shots: int | None = None,\n    **kwargs: Any,\n) -&gt; SampleResultType:\n    \"\"\"\n    Samples the computed result given the expression, the parameters (values), number of\n    shots, and extra arguments.\n\n    :param values: dictionary of user-input parameters\n    :param shots: number of shots\n    :param kwargs: any extra argument that are backends specific can be included in the\n        child method\n    :return: any result type according to what is expected by the backends `sample` method\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/abstracts/#qadence2_platforms.abstracts.AbstractInterface.set_parameters","title":"<code>set_parameters(params)</code>  <code>abstractmethod</code>","text":"<p>Sets valid parameters for the backends to use it during simulation/execution step.</p> <p>:param params: the fixed parameters to be used by the backends.</p> Source code in <code>qadence2_platforms/abstracts.py</code> <pre><code>@abstractmethod\ndef set_parameters(self, params: dict[str, ParameterType]) -&gt; None:\n    \"\"\"\n    Sets valid parameters for the backends to use it during simulation/execution step.\n\n    :param params: the fixed parameters to be used by the backends.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/abstracts/#qadence2_platforms.abstracts.OnEnum","title":"<code>OnEnum</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum class to be used whenever an Interface class method (such as <code>run</code>) needs to specify where to run the code: on emulator or qpu.</p>"},{"location":"api/abstracts/#qadence2_platforms.abstracts.RunEnum","title":"<code>RunEnum</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum class to be used whenever an Interface class method need to specify how to execute the expression: through <code>run</code>, <code>sample</code>, or <code>expectation</code>.</p>"},{"location":"api/compiler/","title":"Qadence 2 platforms compiler","text":""},{"location":"api/compiler/#qadence2_platforms.compiler.compile_to_backend","title":"<code>compile_to_backend(model, backend)</code>","text":"<p>Function that gets a <code>Model</code> (Qadence IR) and a backend name, and.</p> <p>returns an <code>Interface</code> instance from the specific backend with the model transformed into backend appropriate data.</p> <p>:param model: (Model) qadence IR :param backend: (str) the backend to be used to execute the Model :return: (Interface) interface instance of the chosen backend</p> Source code in <code>qadence2_platforms/compiler.py</code> <pre><code>def compile_to_backend(model: Model, backend: str) -&gt; Interface:\n    \"\"\"\n    Function that gets a `Model` (Qadence IR) and a backend name, and.\n\n    returns an `Interface` instance from the specific backend with the\n    model transformed into backend appropriate data.\n\n    :param model: (Model) qadence IR\n    :param backend: (str) the backend to be used to execute the Model\n    :return: (Interface) interface instance of the chosen backend\n    \"\"\"\n\n    plat = module_loader(backend)\n    return cast(Interface, plat.compile_to_backend(model))\n</code></pre>"},{"location":"api/backends/","title":"Qadence 2 Platforms available backends","text":"<p>Here you can find the list of built-in backends for Qadence 2.</p> <p>Currently, there are three backends:</p> <ul> <li><code>Fresnel</code>: Utilizes <code>Pulser</code>'s <code>AnalogDevice</code> object as device with specifications closer to Pasqal's Fresnel-1 QPU.</li> <li><code>Analog</code>: Utilizes <code>Pulser</code>'s <code>AnalogDevice</code> object as device.</li> <li><code>Abstract Analog Backend</code>: Common functionalities to build <code>Pulser</code>-based backends.</li> <li><code>PyQTorch</code>: Utilizes <code>PyQTorch</code> as a backend and performs state vector simulations.</li> </ul>"},{"location":"api/backends/_base_analog/","title":"Abstract analog backend for Pulser-based backends","text":"<p>This abstract analog backend is designed to build <code>Pulser</code>-based backends and, for now, only enables the use of <code>QuTiP</code> emulators.</p>"},{"location":"api/backends/_base_analog/device_settings/","title":"Device Settings","text":""},{"location":"api/backends/_base_analog/device_settings/#qadence2_platforms.backends._base_analog.device_settings.DeviceSettings","title":"<code>DeviceSettings</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Device settings to ease the building of sequence, register and interface logic</p> <p>name (str): the name of the device, ex: <code>Analog Device</code> name_short (str): a shorter name version, ex: <code>analog</code> device (pulser.devices.Device): the pulser device grid_scale_range (tuple[float, float]): a tuple of min and max values for the     grid scale, ex: <code>(1.0, 1.0)</code> (should not scale), <code>(1.0, 10.0)</code> (up to     10.0, included) available_grid_types (tuple[str]): a tuple of all the possible grid types     for the device, ex: <code>(\"triangular\",)</code>, <code>(\"linear\", \"square\")</code> available_directives (tuple[str], optional): a tuple of available directives,     ex: <code>(\"enable_digital_analog\")</code></p>"},{"location":"api/backends/_base_analog/device_settings/#qadence2_platforms.backends._base_analog.device_settings.DeviceSettings.scale_in_range","title":"<code>scale_in_range(grid_scale)</code>","text":"<p>Check whether the grid scale is within device's range.</p> PARAMETER DESCRIPTION <code>grid_scale</code> <p>the grid scale. For a normal grid, the scale is 1.0</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>A boolean to whether the grid scale is within device's range.</p> Source code in <code>qadence2_platforms/backends/_base_analog/device_settings.py</code> <pre><code>def scale_in_range(self, grid_scale: float) -&gt; bool:\n    \"\"\"\n    Check whether the grid scale is within device's range.\n\n    Args:\n        grid_scale (float): the grid scale. For a normal grid, the scale is 1.0\n\n    Returns:\n        A boolean to whether the grid scale is within device's range.\n    \"\"\"\n\n    return self._grid_scale_range[0] &lt;= grid_scale &lt;= self._grid_scale_range[1]\n</code></pre>"},{"location":"api/backends/_base_analog/functions/","title":"Abstract analog backend functions","text":""},{"location":"api/backends/_base_analog/functions/#qadence2_platforms.backends._base_analog.functions.BaseQuTiPObservablesParser","title":"<code>BaseQuTiPObservablesParser</code>","text":"<p>Convert InputType object to Qutip native quantum objects for simulation on QuTiP.</p> <p>It is intended to be used on the expectation method of Pulser-based interface classes. InputType can be qadence2-expressions expression or any other module with the same methods.</p>"},{"location":"api/backends/_base_analog/functions/#qadence2_platforms.backends._base_analog.functions.BaseQuTiPObservablesParser.build","title":"<code>build(num_qubits, observables)</code>  <code>classmethod</code>","text":"<p>Parses an input expression or list of expressions into a native QuTiP object.</p> PARAMETER DESCRIPTION <code>num_qubits</code> <p>the number of qubits to create the qutip object to</p> <p> TYPE: <code>int</code> </p> <code>observables</code> <p>the input expression. Any qadence2-expressions expression compatible object, with the same methods</p> <p> TYPE: <code>(list[InputType], InputType)</code> </p> RETURNS DESCRIPTION <code>list[Qobj]</code> <p>A QuTiP object with the Hilbert space compatible with <code>num_qubits</code></p> Source code in <code>qadence2_platforms/backends/_base_analog/functions.py</code> <pre><code>@classmethod\ndef build(cls, num_qubits: int, observables: list[InputType] | InputType) -&gt; list[qutip.Qobj]:\n    \"\"\"\n    Parses an input expression or list of expressions into a native QuTiP object.\n\n    Args:\n        num_qubits (int): the number of qubits to create the qutip object to\n        observables (list[InputType], InputType): the input expression. Any\n            qadence2-expressions expression compatible object, with the same\n            methods\n\n    Returns:\n        A QuTiP object with the Hilbert space compatible with `num_qubits`\n    \"\"\"\n    if not isinstance(observables, list):\n        return [cls._get_op(num_qubits, observables)]\n    return cls._iterate_over_obs(num_qubits, observables)\n</code></pre>"},{"location":"api/backends/_base_analog/functions/#qadence2_platforms.backends._base_analog.functions.base_parse_native_observables","title":"<code>base_parse_native_observables(num_qubits, observable)</code>","text":"<p>Function to be called by <code>Interface</code>'s <code>expectation</code> method on Pulser-based backends using QuTiP emulator.</p> PARAMETER DESCRIPTION <code>num_qubits</code> <p>number of qubits</p> <p> TYPE: <code>int</code> </p> <code>observable</code> <p>the input expression. Any qadence2-expressions expression compatible object, with the same methods, or a list of it</p> <p> TYPE: <code>list[InputType] | InputType</code> </p> RETURNS DESCRIPTION <code>list[Qobj]</code> <p>A QuTiP object with the Hilbert space compatible with <code>num_qubits</code></p> Source code in <code>qadence2_platforms/backends/_base_analog/functions.py</code> <pre><code>def base_parse_native_observables(\n    num_qubits: int, observable: list[InputType] | InputType\n) -&gt; list[qutip.Qobj]:\n    \"\"\"\n    Function to be called by `Interface`'s `expectation` method on Pulser-based backends\n    using QuTiP emulator.\n\n    Args:\n        num_qubits (int): number of qubits\n        observable (list[InputType] | InputType): the input expression. Any\n            qadence2-expressions expression compatible object, with the same\n            methods, or a list of it\n\n    Returns:\n        A QuTiP object with the Hilbert space compatible with `num_qubits`\n    \"\"\"\n    return BaseQuTiPObservablesParser.build(num_qubits, observable)\n</code></pre>"},{"location":"api/backends/_base_analog/interface/","title":"Abstract analog interface","text":""},{"location":"api/backends/_base_analog/interface/#qadence2_platforms.backends._base_analog.interface.Interface","title":"<code>Interface(sequence, non_trainable_parameters)</code>","text":"<p>               Bases: <code>AbstractInterface[float, Sequence, float, RunResult, Counter, Qobj]</code></p> Source code in <code>qadence2_platforms/backends/_base_analog/interface.py</code> <pre><code>def __init__(self, sequence: Sequence, non_trainable_parameters: set[str]) -&gt; None:\n    self._non_trainable_parameters = non_trainable_parameters\n    self._params: dict[str, float] = dict()\n    self._sequence = sequence\n</code></pre>"},{"location":"api/backends/_base_analog/register/","title":"Abstract analog register","text":""},{"location":"api/backends/_base_analog/register/#qadence2_platforms.backends._base_analog.register.RegisterResolver","title":"<code>RegisterResolver</code>","text":"<p>An object to hold common functionalities for registers and resolving their layouts, transformations and checks.</p>"},{"location":"api/backends/_base_analog/register/#qadence2_platforms.backends._base_analog.register.RegisterResolver.resolve_from_model","title":"<code>resolve_from_model(model, device_settings, grid_scale_fn, grid_type_fn, directives_fn, register_transform_fn)</code>  <code>classmethod</code>","text":"<p>Resolves the model's register data into actual platform appropriate and validated data through platform's own functions. It is a generic and modular helper function to be called by <code>register.from_model</code> function.</p> PARAMETER DESCRIPTION <code>model</code> <p>The model to use and resolve its data</p> <p> TYPE: <code>Model</code> </p> <code>device_settings</code> <p>The device settings instance</p> <p> TYPE: <code>DeviceSettings</code> </p> <code>grid_scale_fn</code> <p>Function used to check the grid scale against the device's</p> <p> TYPE: <code>Callable</code> </p> <code>grid_type_fn</code> <p>Function used to check the grid type against the device's</p> <p> TYPE: <code>Callable</code> </p> <code>directives_fn</code> <p>Function used to check the directives against the device's</p> <p> TYPE: <code>Callable</code> </p> <code>register_transform_fn</code> <p>Function used to transform coordinates into register on appropriate layout</p> <p> TYPE: <code>Callable</code> </p> RETURNS DESCRIPTION <code>RegisterLayout</code> <p>A register data with appropriate layout</p> Source code in <code>qadence2_platforms/backends/_base_analog/register.py</code> <pre><code>@classmethod\ndef resolve_from_model(\n    cls,\n    model: Model,\n    device_settings: DeviceSettings,\n    grid_scale_fn: Callable[[Model], Any],\n    grid_type_fn: Callable[[Model], Any],\n    directives_fn: Callable[[Model], Any],\n    register_transform_fn: Callable[[RegisterTransform], RegisterLayout],\n) -&gt; RegisterLayout:\n    \"\"\"\n    Resolves the model's register data into actual platform appropriate and\n    validated data through platform's own functions. It is a generic and\n    modular helper function to be called by `register.from_model` function.\n\n    Args:\n        model (Model): The model to use and resolve its data\n        device_settings (DeviceSettings): The device settings instance\n        grid_scale_fn (Callable): Function used to check the grid scale\n            against the device's\n        grid_type_fn (Callable): Function used to check the grid type\n            against the device's\n        directives_fn (Callable): Function used to check the directives\n            against the device's\n        register_transform_fn (Callable): Function used to transform\n            coordinates into register on appropriate layout\n\n    Returns:\n        A register data with appropriate layout\n    \"\"\"\n\n    model_register = model.register\n\n    if model_register.num_qubits &lt; 1:\n        raise ValueError(\"No qubit available in the register.\")\n\n    grid_scale_fn(model)\n    grid_type_fn(model)\n    directives_fn(model)\n\n    register_transform = RegisterTransform(\n        grid_transform=model_register.grid_type,\n        grid_scale=model_register.grid_scale,\n        coords=model_register.qubit_positions,\n        num_qubits=model_register.num_qubits,\n        device_settings=device_settings,\n    )\n\n    register = register_transform_fn(register_transform)\n\n    return register\n</code></pre>"},{"location":"api/backends/_base_analog/register/#qadence2_platforms.backends._base_analog.register.RegisterTransform","title":"<code>RegisterTransform(device_settings, grid_transform, grid_scale=1.0, coords=None, num_qubits=None)</code>","text":"<p>Transforms register data according to the <code>grid_type</code> in the <code>qadence2_ir.types.Model</code></p> PARAMETER DESCRIPTION <code>grid_transform</code> <p>literal str to choose which grid transform to use. Accepted values are \"linear\", \"triangular\" or \"square\". If None is provided, it will default to \"triangular\"</p> <p> TYPE: <code>(Literal['linear', 'triangular', 'square'], None)</code> </p> <code>grid_scale</code> <p>scale of the grid. Default is <code>1.0</code></p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <code>coords</code> <p>list of coordinates as qubit positions in an int grid, e.g. <code>[(0, 0), (1, 0), (0, 1)]</code>. Default is <code>None</code></p> <p> TYPE: <code>list[tuple[int, int]]</code> DEFAULT: <code>None</code> </p> <code>num_qubits</code> <p>number of qubits as integer. Default is <code>None</code></p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>device_settings</code> <p>Device settings object</p> <p> TYPE: <code>DeviceSettings | None</code> </p> Source code in <code>qadence2_platforms/backends/_base_analog/register.py</code> <pre><code>def __init__(\n    self,\n    device_settings: DeviceSettings,\n    grid_transform: gridtype_literal | None,\n    grid_scale: float = 1.0,\n    coords: qubits_pos_type | None = None,\n    num_qubits: int | None = None,\n):\n    \"\"\"\n    Args:\n        grid_transform (Literal[\"linear\", \"triangular\", \"square\"], None): literal str to choose\n            which grid transform to use. Accepted values are \"linear\", \"triangular\"\n            or \"square\". If None is provided, it will default to \"triangular\"\n        grid_scale (float): scale of the grid. Default is `1.0`\n        coords (list[tuple[int, int]]): list of coordinates as qubit positions in an int\n            grid, e.g. `[(0, 0), (1, 0), (0, 1)]`. Default is `None`\n        num_qubits (int | None): number of qubits as integer. Default is `None`\n        device_settings (DeviceSettings | None): Device settings object\n    \"\"\"\n\n    self._grid = grid_transform if grid_transform is not None else \"triangular\"\n    self._grid_scale = grid_scale\n\n    if coords:\n        self._raw_coords = coords\n\n    elif num_qubits:\n        self._raw_coords = self._fill_coords(num_qubits)\n\n    else:\n        raise ValueError(\"must provide coords or num_qubits.\")\n\n    try:\n        self.coords = getattr(self, f\"{self._grid}_coords\")()\n    except AttributeError:\n        self.invalid_grid_value()\n    else:\n        self._device = device_settings.device\n</code></pre>"},{"location":"api/backends/_base_analog/register/#qadence2_platforms.backends._base_analog.register.RegisterTransform.get_calibrated_layout","title":"<code>get_calibrated_layout(layout_name)</code>  <code>classmethod</code>","text":"<p>Gets the calibrated layout for the given <code>layout_name</code> according to <code>AnalogDevice</code> specifications.</p> PARAMETER DESCRIPTION <code>layout_name</code> <p>the name of the layout.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>RegisterLayout</code> <p>The <code>RegisterLayout</code> object for the given <code>layout_name</code>.</p> Source code in <code>qadence2_platforms/backends/_base_analog/register.py</code> <pre><code>@classmethod\ndef get_calibrated_layout(cls, layout_name: str) -&gt; RegisterLayout:\n    \"\"\"\n    Gets the calibrated layout for the given `layout_name` according to `AnalogDevice`\n    specifications.\n\n    Args:\n        layout_name: the name of the layout.\n\n    Returns:\n        The `RegisterLayout` object for the given `layout_name`.\n    \"\"\"\n\n    return AnalogDevice.calibrated_register_layouts.get(layout_name, None)\n</code></pre>"},{"location":"api/backends/_base_analog/register/#qadence2_platforms.backends._base_analog.register.RegisterTransform.invalid_grid_value","title":"<code>invalid_grid_value()</code>  <code>classmethod</code>","text":"<p>Fallback function for invalid <code>grid_transform</code> value.</p> Source code in <code>qadence2_platforms/backends/_base_analog/register.py</code> <pre><code>@classmethod\ndef invalid_grid_value(cls) -&gt; None:\n    \"\"\"Fallback function for invalid `grid_transform` value.\"\"\"\n\n    raise ValueError(\"grid_transform should be 'linear', 'triangular', or 'square'.\")\n</code></pre>"},{"location":"api/backends/_base_analog/register/#qadence2_platforms.backends._base_analog.register.RegisterTransform.linear_coords","title":"<code>linear_coords()</code>","text":"<p>Transforms coordinates into linear coordinates.</p> RETURNS DESCRIPTION <code>ndarray</code> <p>np.ndarray of transformed coordinates.</p> Source code in <code>qadence2_platforms/backends/_base_analog/register.py</code> <pre><code>def linear_coords(self) -&gt; np.ndarray:\n    \"\"\"\n    Transforms coordinates into linear coordinates.\n\n    Returns:\n        np.ndarray of transformed coordinates.\n    \"\"\"\n\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/backends/_base_analog/register/#qadence2_platforms.backends._base_analog.register.RegisterTransform.square_coords","title":"<code>square_coords()</code>","text":"<p>Transforms coordinates into square coordinates.</p> RETURNS DESCRIPTION <code>ndarray</code> <p>np.ndarray of transformed coordinates</p> Source code in <code>qadence2_platforms/backends/_base_analog/register.py</code> <pre><code>def square_coords(self) -&gt; np.ndarray:\n    \"\"\"\n    Transforms coordinates into square coordinates.\n\n    Returns:\n        np.ndarray of transformed coordinates\n    \"\"\"\n\n    # for now, no transformation needed since the coords are list of tuple of ints\n    return np.array(self._raw_coords) * self._grid_scale * self.scale_factor\n</code></pre>"},{"location":"api/backends/_base_analog/register/#qadence2_platforms.backends._base_analog.register.RegisterTransform.triangular_coords","title":"<code>triangular_coords()</code>","text":"<p>Transforms coordinates into triangular coordinates.</p> RETURNS DESCRIPTION <code>ndarray</code> <p>np.ndarray of transformed coordinates</p> Source code in <code>qadence2_platforms/backends/_base_analog/register.py</code> <pre><code>def triangular_coords(self) -&gt; np.ndarray:\n    \"\"\"\n    Transforms coordinates into triangular coordinates.\n\n    Returns:\n        np.ndarray of transformed coordinates\n    \"\"\"\n\n    # triangular transformation matrix\n    transform = np.array([[1.0, 0.0], [0.5, 0.8660254037844386]])\n    return np.array(self._raw_coords) * self._grid_scale * self.scale_factor @ transform\n</code></pre>"},{"location":"api/backends/_base_analog/sequence/","title":"Abstract analog sequence","text":""},{"location":"api/backends/analog/","title":"Analog device backend","text":"<p><code>AnalogDevice</code> is the <code>Pulser</code>-based device that uses <code>QuTiP</code> emulator backend and provides a wide range of possibilities to emulate quantum analog computers.</p>"},{"location":"api/backends/analog/compiler/","title":"AnalogDevice compiler","text":""},{"location":"api/backends/analog/functions/","title":"AnalogDevice functions","text":""},{"location":"api/backends/analog/functions/#qadence2_platforms.backends.analog.functions.dyn_pulse","title":"<code>dyn_pulse(sequence, duration, amplitude, detuning, phase, **_)</code>","text":"<p>Dynamic pulse to simulate a specific time-dependent hamiltonian for neutral-atom devices.</p> PARAMETER DESCRIPTION <code>sequence</code> <p>a <code>pulser.sequence.Sequence</code> instance</p> <p> TYPE: <code>Sequence</code> </p> <code>duration</code> <p>duration of the pulse in dimensionless units</p> <p> TYPE: <code>VariableItem | float</code> </p> <code>amplitude</code> <p>amplitude of the pulse in dimensionless units</p> <p> TYPE: <code>VariableItem | float</code> </p> <code>detuning</code> <p>detuning of the pulse in dimensionless units</p> <p> TYPE: <code>VariableItem | float</code> </p> <code>phase</code> <p>phase in radians</p> <p> TYPE: <code>VariableItem | float</code> </p> Source code in <code>qadence2_platforms/backends/analog/functions.py</code> <pre><code>def dyn_pulse(\n    sequence: Sequence,\n    duration: VariableItem | float,\n    amplitude: VariableItem | float,\n    detuning: VariableItem | float,\n    phase: VariableItem | float,\n    **_: Any,\n) -&gt; None:\n    \"\"\"\n    Dynamic pulse to simulate a specific time-dependent hamiltonian for neutral-atom devices.\n\n    Args:\n        sequence: a `pulser.sequence.Sequence` instance\n        duration: duration of the pulse in dimensionless units\n        amplitude: amplitude of the pulse in dimensionless units\n        detuning: detuning of the pulse in dimensionless units\n        phase: phase in radians\n    \"\"\"\n    max_amp = sequence.device.channels[\"rydberg_global\"].max_amp or DEFAULT_AMPLITUDE\n    max_abs_detuning = (\n        sequence.device.channels[\"rydberg_global\"].max_abs_detuning or DEFAULT_DETUNING\n    )\n\n    # FIXME: Centralize unit converions\n    duration *= 1000 * 2 * np.pi / max_amp  # type: ignore\n    amplitude *= max_amp  # type: ignore\n    detuning *= max_abs_detuning  # type: ignore\n\n    new_amplitude = ConstantWaveform(duration, amplitude)\n    new_detuning = ConstantWaveform(duration, detuning)\n\n    p = Pulse(new_amplitude, new_detuning, phase)\n    sequence.add(p, channel=\"global\")\n</code></pre>"},{"location":"api/backends/analog/functions/#qadence2_platforms.backends.analog.functions.piecewise_pulse","title":"<code>piecewise_pulse(sequence, duration, amplitude, detuning, phase, **_)</code>","text":"<p>Dynamic pulse to simulate a specific piecewise time-dependent hamiltonian for neutral-atom devices.</p> PARAMETER DESCRIPTION <code>sequence</code> <p>a <code>pulser.sequence.Sequence</code> instance</p> <p> TYPE: <code>Sequence</code> </p> <code>duration</code> <p>duration of the pulse in dimensionless units</p> <p> TYPE: <code>Variable | VariableItem</code> </p> <code>amplitude</code> <p>amplitude of the pulse in dimensionless units</p> <p> TYPE: <code>Variable</code> </p> <code>detuning</code> <p>detuning of the pulse in dimensionless units</p> <p> TYPE: <code>Variable</code> </p> <code>phase</code> <p>phase in radians</p> <p> TYPE: <code>VariableItem | float</code> </p> Source code in <code>qadence2_platforms/backends/analog/functions.py</code> <pre><code>def piecewise_pulse(\n    sequence: Sequence,\n    duration: Variable | VariableItem,\n    amplitude: Variable,\n    detuning: Variable,\n    phase: VariableItem | float,\n    **_: Any,\n) -&gt; None:\n    \"\"\"\n    Dynamic pulse to simulate a specific piecewise time-dependent hamiltonian for neutral-atom devices.\n\n    Args:\n        sequence: a `pulser.sequence.Sequence` instance\n        duration: duration of the pulse in dimensionless units\n        amplitude: amplitude of the pulse in dimensionless units\n        detuning: detuning of the pulse in dimensionless units\n        phase: phase in radians\n    \"\"\"\n    max_amp = sequence.device.channels[\"rydberg_global\"].max_amp or DEFAULT_AMPLITUDE\n    max_abs_detuning = (\n        sequence.device.channels[\"rydberg_global\"].max_abs_detuning or DEFAULT_DETUNING\n    )\n\n    dur_factor = 1000 * 2 * np.pi / max_amp  # type: ignore\n    amp_factor = max_amp  # type: ignore\n    det_factor = max_abs_detuning  # type: ignore\n\n    # Needed so a size = 1 variable is made iterable\n    duration = [duration] if isinstance(duration, VariableItem) else duration\n\n    for i, dur in enumerate(duration):\n        amp_wf = RampWaveform(\n            dur * dur_factor, amplitude[i] * amp_factor, amplitude[i + 1] * amp_factor\n        )\n        det_wf = RampWaveform(\n            dur * dur_factor, detuning[i] * det_factor, detuning[i + 1] * det_factor\n        )\n        sequence.add(Pulse(amp_wf, det_wf, phase), \"global\")\n</code></pre>"},{"location":"api/backends/analog/interface/","title":"Interface","text":""},{"location":"api/backends/analog/register/","title":"AnalogDevice register","text":""},{"location":"api/backends/analog/register/#qadence2_platforms.backends.analog.register.from_coords","title":"<code>from_coords(register_transform)</code>","text":"<p>Function to transform the coordinates into appropriate register layout.</p> PARAMETER DESCRIPTION <code>register_transform</code> <p>Register transform instance containing the coordinates and register-related data</p> <p> TYPE: <code>RegisterTransform</code> </p> RETURNS DESCRIPTION <code>RegisterLayout</code> <p><code>RegisterLayout</code> data</p> Source code in <code>qadence2_platforms/backends/analog/register.py</code> <pre><code>def from_coords(register_transform: RegisterTransform) -&gt; RegisterLayout:\n    \"\"\"\n    Function to transform the coordinates into appropriate register layout.\n\n    Args:\n        register_transform (RegisterTransform): Register transform instance containing\n            the coordinates and register-related data\n\n    Returns:\n        `RegisterLayout` data\n    \"\"\"\n    register = Register.from_coordinates(register_transform.coords)\n    return register  # type: ignore\n</code></pre>"},{"location":"api/backends/analog/register/#qadence2_platforms.backends.analog.register.from_model","title":"<code>from_model(model)</code>","text":"<p>Gets information from IR model data to generate a register/register layout.</p> PARAMETER DESCRIPTION <code>model</code> <p>IR model data</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>RegisterLayout</code> <p><code>RegisterLayout</code> data</p> Source code in <code>qadence2_platforms/backends/analog/register.py</code> <pre><code>def from_model(model: Model) -&gt; RegisterLayout:\n    \"\"\"\n    Gets information from IR model data to generate a register/register layout.\n\n    Args:\n        model (Model): IR model data\n\n    Returns:\n        `RegisterLayout` data\n    \"\"\"\n\n    register = RegisterResolver.resolve_from_model(\n        model=model,\n        device_settings=AnalogSettings,\n        grid_scale_fn=check_grid_scale,\n        grid_type_fn=check_grid_type,\n        directives_fn=check_directives,\n        register_transform_fn=from_coords,\n    )\n\n    return register\n</code></pre>"},{"location":"api/backends/analog/sequence/","title":"AnalogDevice sequence","text":""},{"location":"api/backends/fresnel1/","title":"Fresnel-1 device backend","text":"<p>Fresnel-1 is the <code>Pulser</code>-based device that uses <code>QuTiP</code> emulator backend and provides specifications closer to Pasqal's Fresnel-1 QPU.</p>"},{"location":"api/backends/fresnel1/compiler/","title":"Fresnel-1 compiler","text":""},{"location":"api/backends/fresnel1/functions/","title":"Fresnel-1 functions","text":""},{"location":"api/backends/fresnel1/functions/#qadence2_platforms.backends.fresnel1.functions.dyn_pulse","title":"<code>dyn_pulse(sequence, duration, amplitude, detuning, phase, **_)</code>","text":"<p>Dynamic pulse to simulate a specific time-dependent hamiltonian for neutral-atom devices.</p> <p>:param sequence: a <code>pulser.sequence.Sequence</code> instance :param duration: duration of the pulse in nanoseconds :param amplitude: amplitude of the pulse in rad/\u00b5s :param detuning: detuning of the pulse in rad/s :param phase: phase in rad</p> Source code in <code>qadence2_platforms/backends/fresnel1/functions.py</code> <pre><code>def dyn_pulse(\n    sequence: Sequence,\n    duration: VariableItem | float,\n    amplitude: VariableItem | float,\n    detuning: VariableItem | float,\n    phase: VariableItem | float,\n    **_: Any,\n) -&gt; None:\n    \"\"\"\n    Dynamic pulse to simulate a specific time-dependent hamiltonian for neutral-atom devices.\n\n    :param sequence: a `pulser.sequence.Sequence` instance\n    :param duration: duration of the pulse in nanoseconds\n    :param amplitude: amplitude of the pulse in rad/\u00b5s\n    :param detuning: detuning of the pulse in rad/s\n    :param phase: phase in rad\n    \"\"\"\n    max_amp = sequence.device.channels[\"rydberg_global\"].max_amp or DEFAULT_AMPLITUDE\n    max_abs_detuning = (\n        sequence.device.channels[\"rydberg_global\"].max_abs_detuning or DEFAULT_DETUNING\n    )\n\n    duration *= 1000 * 2 * np.pi / max_amp  # type: ignore\n    amplitude *= max_amp  # type: ignore\n    detuning *= max_abs_detuning  # type: ignore\n\n    sequence.enable_eom_mode(\"global\", amp_on=amplitude, detuning_on=detuning)\n    sequence.add_eom_pulse(\"global\", duration=duration, phase=phase)  # type: ignore\n    sequence.disable_eom_mode(\"global\")\n</code></pre>"},{"location":"api/backends/fresnel1/interface/","title":"Fresnel-1 Interface","text":""},{"location":"api/backends/fresnel1/register/","title":"Fresnel-1 register","text":""},{"location":"api/backends/fresnel1/register/#qadence2_platforms.backends.fresnel1.register.from_layout","title":"<code>from_layout(register_transform)</code>","text":"<p>Transforms a data from coordinates into a register with calibrated layout.</p> PARAMETER DESCRIPTION <code>register_transform</code> <p>The instance of RegisterTransform containing the coordinates and device settings</p> <p> TYPE: <code>RegisterTransform</code> </p> RETURNS DESCRIPTION <code>RegisterLayout</code> <p>A register data with calibrated layout</p> Source code in <code>qadence2_platforms/backends/fresnel1/register.py</code> <pre><code>def from_layout(register_transform: RegisterTransform) -&gt; RegisterLayout:\n    \"\"\"\n    Transforms a data from coordinates into a register with calibrated layout.\n\n    Args:\n        register_transform (RegisterTransform): The instance of RegisterTransform containing\n            the coordinates and device settings\n\n    Returns:\n        A register data with calibrated layout\n    \"\"\"\n\n    layout = register_transform.get_calibrated_layout(\"TriangularLatticeLayout(61, 5.0\u00b5m)\")\n    traps = layout.get_traps_from_coordinates(*register_transform.coords)\n    register = layout.define_register(*traps, qubit_ids=range(len(traps)))\n\n    return register  # type: ignore\n</code></pre>"},{"location":"api/backends/fresnel1/sequence/","title":"Fresnel-1 sequence","text":""},{"location":"api/backends/pyqtorch/","title":"PyQTorch backend","text":"<p>PyQTorch is the <code>PyQTorch</code>'s backend that relies on <code>Torch</code> for state vector simulations and differentiability.</p>"},{"location":"api/backends/pyqtorch/compiler/","title":"PyQTorch compiler","text":""},{"location":"api/backends/pyqtorch/compiler/#qadence2_platforms.backends.pyqtorch.compiler.Compiler","title":"<code>Compiler</code>","text":"<p>A dataclass to compile an IR model data into PyQTorch objects (to be run in a PyQTorch-based backend.</p>"},{"location":"api/backends/pyqtorch/compiler/#qadence2_platforms.backends.pyqtorch.compiler.Compiler.compile","title":"<code>compile(model)</code>","text":"<p>Compiling IR model data to PyQTorch object function. It transforms model <code>QuInstruct</code>s into PyQTorch operators, resolving the SSA-form arguments into concrete values or valid PyQTorch parameters.</p> PARAMETER DESCRIPTION <code>model</code> <p>IR model to compile</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>QuantumCircuit</code> <p>A PyQTorch quantum circuit object with the model <code>QuInstruct</code>s compiled into</p> <code>QuantumCircuit</code> <p>PyQTorch operators</p> Source code in <code>qadence2_platforms/backends/pyqtorch/compiler.py</code> <pre><code>def compile(\n    self,\n    model: Model,\n) -&gt; pyq.QuantumCircuit:\n    \"\"\"\n    Compiling IR model data to PyQTorch object function. It transforms model\n    `QuInstruct`s into PyQTorch operators, resolving the SSA-form arguments\n    into concrete values or valid PyQTorch parameters.\n\n    Args:\n        model (Model): IR model to compile\n\n    Returns:\n        A PyQTorch quantum circuit object with the model `QuInstruct`s compiled into\n        PyQTorch operators\n    \"\"\"\n\n    pyq_operations = []\n\n    for instr in model.instructions:\n\n        if isinstance(instr, QuInstruct):\n            native_op: QuantumOperation = getattr(\n                pyq, instr.name.upper(), self.instruction_mapping.get(instr.name)\n            )\n            control = instr.support.control\n            target = self._get_target(instr.support.target, model.register.num_qubits)\n            native_support = (*control, *target)\n\n            if len(instr.args) &gt; 0:\n                assert len(instr.args) == 1, \"More than one arg not supported\"\n                (maybe_load,) = instr.args\n                assert isinstance(maybe_load, Load), \"only support load\"\n                pyq_operations.append(\n                    native_op(native_support, maybe_load.variable).to(dtype=torch.complex128)\n                )\n\n            else:\n                pyq_operations.append(native_op(*native_support).to(dtype=torch.complex128))\n\n    return pyq.QuantumCircuit(model.register.num_qubits, pyq_operations).to(\n        dtype=torch.complex128\n    )\n</code></pre>"},{"location":"api/backends/pyqtorch/compiler/#qadence2_platforms.backends.pyqtorch.compiler.compile_to_backend","title":"<code>compile_to_backend(model)</code>","text":"<p>Compiles the model data (IR information from expressions) into PyQTorch-compatible data and defines an Interface instance to be available to the user to invoke useful methods, such as <code>run</code>, <code>sample</code>, <code>expectation</code>, <code>set_parameters</code>.</p> PARAMETER DESCRIPTION <code>model</code> <p>the IR model data to be compiled to PyQTorch-based backend</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>Interface</code> <p>The <code>Interface</code> instance based on PyQTorch backend</p> Source code in <code>qadence2_platforms/backends/pyqtorch/compiler.py</code> <pre><code>def compile_to_backend(model: Model) -&gt; Interface:\n    \"\"\"\n    Compiles the model data (IR information from expressions) into PyQTorch-compatible data and\n    defines an Interface instance to be available to the user to invoke useful methods, such as\n    `run`, `sample`, `expectation`, `set_parameters`.\n\n    Args:\n        model (Model): the IR model data to be compiled to PyQTorch-based backend\n\n    Returns:\n        The `Interface` instance based on PyQTorch backend\n    \"\"\"\n\n    register_interface = RegisterInterface(\n        model.register.num_qubits, model.register.options.get(\"init_state\")\n    )\n    embedding = Embedding(model)\n    native_circ = Compiler().compile(model)\n    vparams = get_trainable_params(model.inputs)\n    return Interface(register_interface, embedding, native_circ, vparams=vparams)\n</code></pre>"},{"location":"api/backends/pyqtorch/embedding/","title":"PyQTorch embedding","text":""},{"location":"api/backends/pyqtorch/embedding/#qadence2_platforms.backends.pyqtorch.embedding.Embedding","title":"<code>Embedding(model)</code>","text":"<p>               Bases: <code>Module</code></p> <p>A class holding:</p> <ul> <li>A parameterbuffer containing concretized vparams + list of featureparams,</li> <li>A dictionary of intermediate and leaf variable names mapped to a TorchCall object     which can be results of function/expression evaluations.</li> </ul> Source code in <code>qadence2_platforms/backends/pyqtorch/embedding.py</code> <pre><code>def __init__(self, model: Model) -&gt; None:\n    super().__init__()\n    self.param_buffer = ParameterBuffer.from_model(model)\n    self.var_to_torchcall: dict[str, Callable] = self.create_var_to_torchcall_mapping(model)\n</code></pre>"},{"location":"api/backends/pyqtorch/embedding/#qadence2_platforms.backends.pyqtorch.embedding.Embedding.__call__","title":"<code>__call__(inputs)</code>","text":"<p>Expects a dict of user-passed name:value pairs for featureparameters.</p> <p>and assigns all intermediate and leaf variables using the current vparam values and the passed values for featureparameters.</p> Source code in <code>qadence2_platforms/backends/pyqtorch/embedding.py</code> <pre><code>def __call__(self, inputs: dict[str, torch.Tensor]) -&gt; dict[str, torch.Tensor]:\n    \"\"\"\n    Expects a dict of user-passed name:value pairs for featureparameters.\n\n    and assigns all intermediate and leaf variables using the current vparam values\n    and the passed values for featureparameters.\n    \"\"\"\n    assigned_params: dict[str, torch.Tensor] = {}\n    try:\n        # TODO: check why it is failing (doesn't affect code reliability apparently)\n        assert inputs.keys() == self.param_buffer.fparams.keys()\n    except Exception as _:\n        pass\n    for var, torchcall in self.var_to_torchcall.items():\n        assigned_params[var] = torchcall(\n            self.param_buffer.vparams,\n            {\n                **inputs,\n                **assigned_params,\n            },  # we add the \"intermediate\" variables too\n        )\n    assigned_params = {**assigned_params, **inputs}\n    return assigned_params\n</code></pre>"},{"location":"api/backends/pyqtorch/embedding/#qadence2_platforms.backends.pyqtorch.embedding.ParameterBuffer","title":"<code>ParameterBuffer(trainable_vars, non_trainable_vars)</code>","text":"<p>               Bases: <code>Module</code></p> <p>A class holding all root parameters either passed by the user.</p> <p>or trainable variational parameters.</p> Source code in <code>qadence2_platforms/backends/pyqtorch/embedding.py</code> <pre><code>def __init__(\n    self,\n    trainable_vars: list[str],\n    non_trainable_vars: list[str],\n) -&gt; None:\n    super().__init__()\n    self.vparams = {p: torch.rand(1, requires_grad=True) for p in trainable_vars}\n    self.fparams = {p: None for p in non_trainable_vars}\n    self._dtype = torch.float64\n    self._device = torch.device(\"cpu\")\n</code></pre>"},{"location":"api/backends/pyqtorch/embedding/#qadence2_platforms.backends.pyqtorch.embedding.torch_call","title":"<code>torch_call(call)</code>","text":"<p>Convert a <code>Call</code> object into a torchified function which can be evaluated using.</p> <p>a vparams and inputs dict.</p> Source code in <code>qadence2_platforms/backends/pyqtorch/embedding.py</code> <pre><code>def torch_call(call: Call) -&gt; Callable[[dict, dict], torch.Tensor]:\n    \"\"\"\n    Convert a `Call` object into a torchified function which can be evaluated using.\n\n    a vparams and inputs dict.\n    \"\"\"\n    fn = getattr(torch, call.identifier)\n\n    def evaluate(params: dict, inputs: dict) -&gt; torch.Tensor:\n        args = []\n        for symbol in call.args:\n            if isinstance(symbol, float):\n                # NOTE we compile constants into each TorchCallable instead of passing\n                # them around in the values dict\n                args.append(torch.tensor(symbol))\n            elif isinstance(symbol, Load):\n                args.append({**params, **inputs}[symbol.variable])\n        return fn(*args)\n\n    return evaluate\n</code></pre>"},{"location":"api/backends/pyqtorch/functions/","title":"PyQTorch functions","text":""},{"location":"api/backends/pyqtorch/functions/#qadence2_platforms.backends.pyqtorch.functions.PyQObservablesParser","title":"<code>PyQObservablesParser</code>","text":"<p>Convert InputType object observables into native PyQTorch object, especially for running <code>expectation</code> method from PyQTorch interface class. InputType can be qadence2-expressions or any other module that implement the same methods.</p>"},{"location":"api/backends/pyqtorch/functions/#qadence2_platforms.backends.pyqtorch.functions.PyQObservablesParser.build","title":"<code>build(observable)</code>  <code>classmethod</code>","text":"<p>Parses an input expression or list of expressions into a native PyQTorch object.</p> PARAMETER DESCRIPTION <code>observable</code> <p>the input expression. Any qadence2-expressions expression compatible object or object with same methods.</p> <p> TYPE: <code>list[InputType] | InputType</code> </p> RETURNS DESCRIPTION <code>Observable</code> <p>An PyQTorch Observable object.</p> Source code in <code>qadence2_platforms/backends/pyqtorch/functions.py</code> <pre><code>@classmethod\ndef build(cls, observable: list[InputType] | InputType) -&gt; Observable:\n    \"\"\"\n    Parses an input expression or list of expressions into a native PyQTorch object.\n\n    Args:\n        observable (list[InputType] | InputType): the input expression. Any\n            qadence2-expressions expression compatible object or object with same\n            methods.\n\n    Returns:\n        An PyQTorch Observable object.\n    \"\"\"\n\n    res: list[Module] | Module\n    if isinstance(observable, list):\n        res = cls._iterate_over_obs(observable)\n    else:\n        res = [cls._get_op(observable)]\n    return Observable(res)\n</code></pre>"},{"location":"api/backends/pyqtorch/interface/","title":"Interface","text":""},{"location":"api/backends/pyqtorch/interface/#qadence2_platforms.backends.pyqtorch.interface.Interface","title":"<code>Interface(register, embedding, circuit, vparams=None, observable=None)</code>","text":"<p>               Bases: <code>AbstractInterface[Tensor, QuantumCircuit, Tensor, Tensor, list[Counter], Tensor]</code></p> <p>A class holding register, embedding, circuit, native backends and optional observable.</p> Source code in <code>qadence2_platforms/backends/pyqtorch/interface.py</code> <pre><code>def __init__(\n    self,\n    register: RegisterInterface,\n    embedding: Embedding,\n    circuit: pyq.QuantumCircuit,\n    vparams: dict[str, torch.Tensor] = None,\n    observable: list[InputType] | InputType | None = None,\n) -&gt; None:\n    super().__init__()\n    self.register = register\n    self.init_state: torch.Tensor = (\n        circuit.state_from_bitstring(register.init_state)\n        if register.init_state is not None\n        else circuit.init_state()\n    ).to(dtype=torch.complex128)\n    self.embedding = embedding\n    self.circuit = circuit\n    self.observable = observable\n    self.vparams = ParameterDict(vparams)\n    self._dtype = torch.float64\n</code></pre>"},{"location":"api/backends/pyqtorch/register/","title":"PyQTorch register","text":""},{"location":"api/utils/","title":"Utils","text":"<p>This module provides a set of functionalities to build custom backends and also to look for them when compiling IR model data into backends with Qadence 2 platforms.</p>"},{"location":"api/utils/backend_template/","title":"Backend template","text":""},{"location":"api/utils/backend_template/#qadence2_platforms.utils.backend_template.BackendTemplate","title":"<code>BackendTemplate()</code>","text":"<p>Class to create new custom backend folder with file templates.</p> <p>It will follow the same structure as the built-in backends, namely <code>fresnel1</code> and <code>pyqtorch</code>, having a folder with the custom backend name with the essential files inside already built with the functions, classes and their methods.</p> <p>Ex:</p> <pre><code>selected_root_dir/\n\u2514\u2500\u2500 custom_backends/\n    \u251c\u2500\u2500 custom_backend1/\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 compiler.py\n    \u2502   \u2514\u2500\u2500 interface.py\n</code></pre> <p>It is intended to help the user when creating their custom backend with pre-filled files so the core structure of the backend instances are still present, while giving freedom for them to implement whatever else needed.</p> Source code in <code>qadence2_platforms/utils/backend_template.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._pwd: Path = Path()\n    self._root_backends_name: str = CUSTOM_BACKEND_FOLDER_NAME\n    self._backend_name: str = \"\"\n    self._backend_path: Path = Path()\n    self._template_path: Path = self._get_template_path()\n    self._template_files_list: list[str] = os.listdir(self._template_path)\n</code></pre>"},{"location":"api/utils/backend_template/#qadence2_platforms.utils.backend_template.BackendTemplate.create_folder","title":"<code>create_folder(backend_name, current_path)</code>","text":"<p>Creates the main folder for the custom backend in a selected path.</p> PARAMETER DESCRIPTION <code>backend_name</code> <p>backend name</p> <p> TYPE: <code>str</code> </p> <code>current_path</code> <p>current path to place the custom backend</p> <p> TYPE: <code>(str, Path)</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Returns true if the folder was already existing</p> Source code in <code>qadence2_platforms/utils/backend_template.py</code> <pre><code>def create_folder(self, backend_name: str, current_path: str | Path) -&gt; bool:\n    \"\"\"\n    Creates the main folder for the custom backend in a selected path.\n\n    Args:\n        backend_name (str): backend name\n        current_path (str, Path): current path to place the custom backend\n\n    Returns:\n        Returns true if the folder was already existing\n    \"\"\"\n\n    self._backend_name = backend_name\n    self._pwd = Path(current_path)\n    self._backend_path = Path(self._pwd, self._root_backends_name, self._backend_name)\n    already_exists = os.path.exists(self._backend_path)\n    self._backend_path.mkdir(parents=True, exist_ok=True)\n    return already_exists\n</code></pre>"},{"location":"api/utils/backend_template/#qadence2_platforms.utils.backend_template.BackendTemplate.create_template","title":"<code>create_template(backend_name, gui=True, use_this_dir=None)</code>","text":"<p>Creates the template, with the main custom backend folder and its content files.</p> PARAMETER DESCRIPTION <code>backend_name</code> <p>backend name</p> <p> TYPE: <code>str</code> </p> <code>gui</code> <p>whether to use a GUI option to choose where to create the template; tkinter must be installed. On Mac: <code>brew install python-tk@python3.10</code>. In case you use a different python version, replace <code>3.10</code> by it. On Linux: <code>apt-get install python-tk</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>use_this_dir</code> <p>directory to create the custom backend</p> <p> TYPE: <code>str | Path | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Returns true if the template was successfully created</p> Source code in <code>qadence2_platforms/utils/backend_template.py</code> <pre><code>def create_template(\n    self,\n    backend_name: str,\n    gui: bool = True,\n    use_this_dir: str | Path | None = None,\n) -&gt; bool:\n    \"\"\"\n    Creates the template, with the main custom backend folder and its content files.\n\n    Args:\n        backend_name (str): backend name\n        gui (bool): whether to use a GUI option to choose where to create the template;\n            tkinter must be installed.\n            On Mac: `brew install python-tk@python3.10`. In case you use a different python\n            version, replace `3.10` by it. On Linux: `apt-get install python-tk`.\n        use_this_dir (str | Path | None): directory to create the custom backend\n\n    Returns:\n         Returns true if the template was successfully created\n    \"\"\"\n\n    print(\n        \"\\nCreating a backend template.\\n\\n\"\n        \"You need to select a directory where all the custom backends will be located.\\n\"\n        \" The organization will be as follows:\\n\\n\"\n        \"   selected_root_dir/\\n\"\n        \"   \u2514\u2500\u2500 custom_backends/\\n\"\n        \"       \u251c\u2500\u2500 custom_backend1/\\n\"\n        \"       \u2502   \u251c\u2500\u2500 __init__.py\\n\"\n        \"       \u2502   \u251c\u2500\u2500 compiler.py\\n\"\n        \"       \u2502   \u2514\u2500\u2500 interface.py\\n\"\n        \"       \u251c\u2500\u2500 custom_backend2/\\n\"\n        \"       ...\\n\"\n        \"\"\n    )\n\n    selected_dir: str | Path\n\n    if gui and use_this_dir is None and \"tkinter\" in sys.modules:\n        selected_dir = user_input()\n    else:\n        if use_this_dir is None:\n            selected_dir = user_input()\n        else:\n            selected_dir = use_this_dir\n\n    if selected_dir:\n        try:\n            already_exists = self.create_folder(backend_name, current_path=selected_dir)\n            self.create_files()\n        except Exception:\n            traceback.print_exc()\n            return False\n        else:\n            action = \"replaced\" if already_exists else \"created\"\n            result = resolve_module_path(Path(selected_dir, CUSTOM_BACKEND_FOLDER_NAME))\n            if result:\n                print(\n                    f\"Backend template at {self._backend_path} has been {action} with success!\"\n                )\n            return result\n    else:\n        print(\"You must select a directory to create the template. Creation suspended.\")\n        return False\n</code></pre>"},{"location":"api/utils/module_importer/","title":"Module importer","text":""},{"location":"api/utils/module_importer/#qadence2_platforms.utils.module_importer.module_loader","title":"<code>module_loader(module_name)</code>","text":"<p>Loads an arbitrary module and returns it.</p> <p>It can be a backend submodule from an already imported backend, i.e. <code>\"pyqtorch\"</code>, an existing but not imported module, i.e. <code>\"fresnel1\"</code>, or a custom backend module, i.e. <code>\"custom_backend1\"</code>.</p> <p>It facilitates to import and work with custom modules for backends development, for instance.</p> PARAMETER DESCRIPTION <code>module_name</code> <p>The name of the module to load.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>ModuleType</code> <p>The loaded module.</p> Source code in <code>qadence2_platforms/utils/module_importer.py</code> <pre><code>def module_loader(module_name: str) -&gt; ModuleType:\n    \"\"\"\n    Loads an arbitrary module and returns it.\n\n    It can be a backend submodule from\n    an already imported backend, i.e. `\"pyqtorch\"`, an existing but not imported\n    module, i.e. `\"fresnel1\"`, or a custom backend module, i.e. `\"custom_backend1\"`.\n\n    It facilitates to import and work with custom modules for backends development,\n    for instance.\n\n    Args:\n        module_name (str): The name of the module to load.\n\n    Returns:\n        The loaded module.\n    \"\"\"\n\n    base_backend = f\"{BASE_BACKEND_MODULE}.{module_name}\"\n    if base_backend in sys.modules:\n        return sys.modules[base_backend]\n    user_backend = f\"{USER_BACKEND_MODULE}.{module_name}\"\n    if user_backend in sys.modules:\n        return sys.modules[user_backend]\n\n    module: ModuleType\n    try:\n        module = import_module(base_backend)\n    except ModuleNotFoundError:\n        try:\n            module = import_module(user_backend)\n        except ModuleNotFoundError:\n            traceback.print_exc()\n            error_msg = (\n                f\"Module error. Please verify module '{module_name}'. \"\n                f\"You may need to import it beforehand. \"\n                f\"In case it is a custom module, please double check its path and\"\n                f\"use `pathlib.Path` class instead of pure `str`.\"\n            )\n            logger.error(ModuleError(error_msg))\n            raise ModuleError(error_msg)\n    return module\n</code></pre>"},{"location":"api/utils/module_importer/#qadence2_platforms.utils.module_importer.resolve_module_path","title":"<code>resolve_module_path(module_source)</code>","text":"<p>Resolve module path for custom backends.</p> <p>It symlinks custom backends, if they are not symlinked yet, and ensure that relative imports from their files do not break.</p> PARAMETER DESCRIPTION <code>module_source</code> <p>module source path.</p> <p> TYPE: <code>str | Path</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the module path is resolved, False otherwise.</p> Source code in <code>qadence2_platforms/utils/module_importer.py</code> <pre><code>def resolve_module_path(module_source: str | Path) -&gt; bool:\n    \"\"\"\n    Resolve module path for custom backends.\n\n    It symlinks custom backends,\n    if they are not symlinked yet, and ensure that relative imports from\n    their files do not break.\n\n    Args:\n        module_source (str | Path): module source path.\n\n    Returns:\n        True if the module path is resolved, False otherwise.\n    \"\"\"\n\n    platforms_spec = find_spec(\"qadence2_platforms\")\n    if platforms_spec is None:\n        return False\n\n    if platforms_spec.origin is None:\n        return False\n\n    platforms_path = Path(platforms_spec.origin).parent\n    src = Path(module_source).resolve()\n\n    try:\n        dst = platforms_path / USER_BACKENDS_FOLDER_NAME\n        dst.symlink_to(src, target_is_directory=True)\n    except FileExistsError:\n        return True\n    except Exception:\n        traceback.print_exc()\n        return False\n    return True\n</code></pre>"},{"location":"contents/","title":"Qadence 2 Platforms","text":"<p>Qadence 2 Platforms is a collection of functionalities that transforms Qadence IR into backend-specific data and constructors, to be executed by backend methods. It is not intended to be used directly by Qadence 2 users, but rather those who need to implement or extend backends, quantum instruction primitives, compiler or backend directives, etc.</p>"},{"location":"contents/abstracts/","title":"Abstracts objects","text":"<p>This module defines the bare bone of the Qadence 2 platforms. The <code>AbstractInterface</code> sets all the necessary methods that must be shared by all the backends in order to function properly when the user runs <code>expectation</code>  or <code>sample</code> method, for instance, for a given expression. Additional <code>Enum</code> classes are defined as well to enable the user to choose the right flags on the methods calls.</p>"},{"location":"contents/backends/","title":"Backends","text":"<p>The backends are a collection of platform-specific functionalities to provide the proper IR model data transformation and execution on chosen simulators or real devices. They are designed to behave in a standardized way to provide code extensibility and are flexible enough so advanced users can create their own backends.</p> <p>Current available built-in backends are <code>Fresnel-1</code>, <code>AnalogDevice</code>, and <code>PyQTorch</code>.</p>"},{"location":"contents/compiler/","title":"Compiling to backend","text":"<p>The Qadence 2 internals rely on a few function calls to go from expressions to backend execution. On Qadence 2 platforms, the function responsible for this is <code>compile_to_backend</code>. It creates the bridge between Qadence 2 IR model data and the correct backend defined by the user (or by the compiler). When the user chooses the backend name on Qadence 2 (<code>qadence2-core</code>) at the <code>code_compile</code> function, this information is passed to <code>compile_to_backend</code> to look for the correct backend (using <code>module_importer</code> logic) and, if it exists, backend's <code>compile_to_backend</code> function will be invoked, generating an <code>Interface</code> instance.</p>"},{"location":"contents/utils/","title":"Utils","text":"<p>This module contains functionalities to handle custom backend creation and dynamic importing of backends.</p> <p>Custom backends can be created through the <code>BackendTemplate</code> class which will provide all the necessary code template that must exist in order for Qadence 2 platforms to properly find and generate the <code>Interface</code> instance. For more information on how to create a custom backend, check this tutorial page.</p> <p>The <code>module_importer</code> provides a dynamic import for both built-in and custom backends.</p>"},{"location":"getting_started/CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"getting_started/CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"getting_started/CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"getting_started/CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"getting_started/CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"getting_started/CONTRIBUTING/","title":"How to contribute","text":"<p>We're grateful for your interest in participating in Qadence 2 Platforms. Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"getting_started/CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an issue or proposing a feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to qadence 2 platforms, feel free to create an issue on qadence 2 platforms' GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"getting_started/CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a pull request","text":"<p>We're excited that you're eager to contribute to Qadence 2 Platforms. To contribute, fork the <code>main</code> branch of qadence 2 platforms repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button at the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/qadence2-platforms</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/qadence2-platforms.git\n</code></pre> <p>Next, navigate to your new qadence 2 platforms fork directory and mark the main qadence 2 platforms repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/qadence2-platforms.git\n</code></pre>"},{"location":"getting_started/CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within qadence 2 platforms, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run qadence 2 platforms tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\npip install -e .\npytest\n</code></pre>"},{"location":"getting_started/CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful things for your workflow: linting and testing","text":"<p>Use <code>pre-commit</code> to lint your code and run the unit tests before pushing a new commit.</p> <p>Using <code>hatch</code>, it's simply:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Our CI/CD pipeline will also test if the documentation can be built correctly. To test it locally, please run:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"},{"location":"getting_started/LICENSE/","title":"Apache License","text":"<p>Version 2.0, January 2004</p> <p>http://www.apache.org/licenses/</p>"},{"location":"getting_started/LICENSE/#terms-and-conditions-for-use-reproduction-and-distribution","title":"TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION","text":""},{"location":"getting_started/LICENSE/#1-definitions","title":"1. Definitions:","text":"<p>\"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.</p>"},{"location":"getting_started/LICENSE/#2-grant-of-copyright-license","title":"2. Grant of Copyright License.","text":"<p>Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.</p>"},{"location":"getting_started/LICENSE/#3-grant-of-patent-license","title":"3. Grant of Patent License.","text":"<p>Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.</p>"},{"location":"getting_started/LICENSE/#4-redistribution","title":"4. Redistribution.","text":"<p>You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:</p> <ul> <li> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> </li> <li> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> </li> <li> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> </li> <li> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> </li> </ul> <p>You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.</p>"},{"location":"getting_started/LICENSE/#5-submission-of-contributions","title":"5. Submission of Contributions.","text":"<p>Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.</p>"},{"location":"getting_started/LICENSE/#6-trademarks","title":"6. Trademarks.","text":"<p>This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.</p>"},{"location":"getting_started/LICENSE/#7-disclaimer-of-warranty","title":"7. Disclaimer of Warranty.","text":"<p>Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.</p>"},{"location":"getting_started/LICENSE/#8-limitation-of-liability","title":"8. Limitation of Liability.","text":"<p>In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.</p>"},{"location":"getting_started/LICENSE/#9-accepting-warranty-or-additional-liability","title":"9. Accepting Warranty or Additional Liability.","text":"<p>While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.</p>"},{"location":"getting_started/LICENSE/#end-of-terms-and-conditions","title":"END OF TERMS AND CONDITIONS","text":""},{"location":"getting_started/example/","title":"Example","text":"<p>Note</p> <p>The code below is not intended to be used as is, but rather just to show how data flows from expression, to compilation, to IR and to platforms. Those features are wrapped in the user-accessible package <code>Qadence 2</code>.</p>"},{"location":"getting_started/example/#computing-grad-for-an-expression","title":"Computing <code>grad</code> for an expression","text":"<pre><code>import torch\nimport pyqtorch as pyq\nfrom qadence2_ir.types import (\n    Model,\n    Alloc,\n    AllocQubits,\n    Call,\n    Load,\n    Support,\n    QuInstruct,\n    Assign\n)\nfrom qadence2_platforms.compiler import compile_to_backend\n\n\n# define the model\nmodel = Model(\n    register=AllocQubits(num_qubits=2, options={\"initial_state\": \"10\"}),\n    inputs={\n        \"x\": Alloc(size=1, trainable=False),\n    },\n    instructions=[\n        Assign(\"%0\", Call(\"mul\", 1.57, Load(\"x\"))),\n        Assign(\"%1\", Call(\"sin\", Load(\"%0\"))),\n        QuInstruct(\"rx\", Support(target=(0,)), Load(\"%1\")),\n        QuInstruct(\"not\", Support(target=(1,), control=(0,))),\n    ],\n    directives={\"digital\": True},\n)\n\n# place the model and choose the backend in `compile_to_backend` function\ncompiled_model = compile_to_backend(model, \"pyqtorch\")\n\n# define the feature parameters values that are used in the `Model`\nfeature_params = {\"x\": torch.rand(1, requires_grad=True)}\n\n# run the `Model` execution to retrieve a wavefunction as `torch.Tensor`\nwavefunction = compiled_model.run(state=pyq.zero_state(2), values=feature_params)\n\n# calculate the `grad` from the wavefunction, given the feature parameters\ndfdx = torch.autograd.grad(wavefunction, feature_params[\"x\"], torch.ones_like(wavefunction))\n\nprint(dfdx)\n</code></pre> <pre><code>(tensor([-0.1492]),)\n</code></pre> <p>Above is a working example on how to use <code>Qadence 2 platforms</code> package. We first need a <code>Model</code> data to work with (from <code>Qadence 2 IR</code>), which is a qadence 2 expression compiled into an IR. Once the model is defined, a backend must be chosen. A <code>compile_to_backend</code> should be invoked to translate the model data into backend-specific data, and also to expose backend's methods and functionalities to execute the model data code. The execution can be done in emulators or QPU, with sampling or expectation values, for instance.</p> <p>In the case below, <code>torch</code> data is used, which is differentiable, so <code>autograd</code> can be done in the user input tensor. <code>PyQTorch</code> is defined as backend and thus the <code>Model</code> will be converted into <code>torch</code> tensor data, for a wavefunction calculation through the backend <code>Interface</code> method called <code>run</code>.</p>"},{"location":"getting_started/installation/","title":"Qadence 2 Platforms","text":"<p>Note</p> <p>Qadence 2 Platforms is currently a work in progress and is under active development.</p> <p>Please be aware that the software is in an early stage, and frequent updates, including breaking changes, are to be expected. This means that:</p> <ul> <li>Features and functionalities may change without prior notice.</li> <li>The codebase is still evolving, and parts of the software may not function as intended.</li> <li>Documentation and user guides may be incomplete or subject to significant changes.</li> </ul> <p>Qadence 2 Platforms is a collection of functionalities that transforms Qadence IR into backend-specific data and constructors, to be executed by backend methods. It is not intended to be used directly by Qadence 2 users, but rather only those who need to implement new or extend existing backends, quantum instruction primitives, and compiler or backend directives, etc.</p>"},{"location":"getting_started/installation/#installation","title":"Installation","text":"<p>Note</p> <p>It is advised to set up a python environment before installing the package, such as venv, hatch, pyenv, conda or poetry. (Qadence 2 in development mode uses <code>hatch</code>).</p> <p>To install the current version, there are a few option:</p>"},{"location":"getting_started/installation/#installation-from-pypi","title":"Installation from PYPI","text":"<p>On the terminal, type</p> <pre><code>pip install qadence2-platforms\n</code></pre>"},{"location":"getting_started/installation/#installation-from-source","title":"Installation from Source","text":"<p>Clone this repository by typing on the terminal</p> <pre><code>git clone https://github.com/pasqal-io/qadence2-platforms.git\n</code></pre> <p>Go to <code>qadence2-platforms</code> folder and install it using hatch:</p> <pre><code>python -m pip install hatch\n</code></pre> <p>and run <code>hatch</code> to create or reuse the project environment:</p> <pre><code>hatch -v shell\n</code></pre>"},{"location":"getting_started/installation/#description","title":"Description","text":""},{"location":"getting_started/installation/#platforms","title":"Platforms","text":"<p>This package should not be used directly by the user. It is used to convert Qadence 2 IR into backend-compatible data, and to execute it with extra options (provided by the compilation process, either on Qadence 2 expressions or Qadence 2 core).</p>"},{"location":"getting_started/installation/#qadence-2-intermediate-representation-q2ir","title":"Qadence 2 Intermediate Representation (Q2IR)","text":"<p>Qadence 2 expressions is compiled into an IR comprised of both quantum and classical operations.</p>"},{"location":"getting_started/installation/#platforms-api","title":"Platforms API","text":"<p>The <code>backend</code> module exposes a single <code>compile_to_backend</code> function which accepts a <code>Model</code> and a string denoting the <code>backend</code>.</p>"},{"location":"getting_started/installation/#platforms-backend","title":"Platforms Backend","text":"<p>Each submodule under <code>backend</code> is expected (1) to translate the <code>IR</code> data into backend-compatible data, (2) to provide instruction conversions from <code>IR</code> to backend, (3) to handle the storage and embedding of parameters, and (4) to implement execution process for <code>run</code>, <code>sample</code> and <code>expectation</code>.</p>"},{"location":"getting_started/installation/#example","title":"Example","text":"<p>Check the Example tab for usage example of this package.</p>"},{"location":"getting_started/installation/#contributing","title":"Contributing","text":"<p>Before making a contribution, please review our code of conduct.</p> <ul> <li>Submitting Issues: To submit bug reports or feature requests, please use our issue tracker.</li> <li>Developing in qadence 2 platforms: To learn more about how to develop within <code>qadence 2 platforms</code>, please refer to contributing guidelines.</li> </ul>"},{"location":"tutorials/backend_creation/","title":"Building a custom backend","text":"<p>It is possible to build your own custom backend on Qadence 2 platforms.</p>"},{"location":"tutorials/backend_creation/#why-building-your-own-backend","title":"Why building your own backend","text":"<ul> <li>Define a new device and have a full custom experience</li> <li>Customize primitive functions to test or extend ideas, new parameters, etc.</li> <li>Customize emulation backend</li> </ul>"},{"location":"tutorials/backend_creation/#how-to-build-your-own-backend","title":"How to build your own backend","text":"<p>Here is a brief description on how you can create your own backend:</p> <pre><code>from pathlib import Path\nfrom qadence2_platforms.utils import BackendTemplate\n\nmy_path = Path(\"../contents\")\n\ntemplate = BackendTemplate()\ntemplate.create_template(\"my_backend1\", gui=False, use_this_dir=my_path)\n</code></pre> <p>And it is done! Now you have go through the newly created <code>custom_backends/my_backend1</code> folder at the current folder (defined in <code>Path(\".\")</code>) and implement all the necessary methods. <code>BackendTemplate</code> instance also creates a few necessary files, such as <code>compiler.py</code> and <code>interface.py</code> with pre-filled code. There is a comprehensive list of TODOs inside those files so you can properly implement what is needed for your backend to successfully be used by <code>qadence2-platforms</code>.</p>"},{"location":"tutorials/examples/","title":"Examples","text":"<p>Note</p> <p>This is a work in progress</p>"}]}